name: Sarif upload workflow

on:
  push:
    branches:
      - main
      - Dev
  pull_request:
    branches:
      - main
      - Dev

permissions:
  contents: read
  security-events: write
  pull-requests: write # Necessário para o bot comentar no PR

jobs:
  security:
    name: Run Security Scans (Trivy + Bandit + ZAP)
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: 3.9

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install bandit

      # ---------------------- TRIVY - requirements.txt ----------------------
      - name: Run Trivy vulnerability scanner for requirements.txt
        uses: aquasecurity/trivy-action@0.20.0
        with:
          scan-type: 'fs'
          scan-ref: 'requirements.txt'
          format: 'sarif'
          limit-severities-for-sarif: false
          output: 'trivy-results-main.sarif' # Nome de arquivo único

      - name: Upload Trivy SARIF results for requirements.txt to Code Scanning
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: trivy-results-main.sarif
          category: 'trivy-main-requirements' # Categoria única

      - name: Upload Trivy Main SARIF Artifact
        uses: actions/upload-artifact@v4 # Atualizado para v4
        with:
          name: trivy-main-sarif # Nome do artefato
          path: trivy-results-main.sarif # Caminho do arquivo a ser upado

      # ---------------------- TRIVY - web_interface/requirements.txt ----------------------
      - name: Run Trivy vulnerability scanner for web_interface/requirements.txt
        uses: aquasecurity/trivy-action@0.20.0
        with:
          scan-type: 'fs'
          scan-ref: 'web_interface/requirements.txt'
          format: 'sarif'
          limit-severities-for-sarif: false
          output: 'trivy-results-web.sarif' # Nome de arquivo único

      - name: Upload Trivy SARIF results for web_interface/requirements.txt to Code Scanning
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: trivy-results-web.sarif
          category: 'trivy-web-requirements' # Categoria única

      - name: Upload Trivy Web SARIF Artifact
        uses: actions/upload-artifact@v4 # Atualizado para v4
        with:
          name: trivy-web-sarif # Nome do artefato
          path: trivy-results-web.sarif # Caminho do arquivo a ser upado

      # ---------------------- BANDIT ----------------------
      - name: Run Bandit scan
        run: |
          bandit -r web_interface/ -f json -o bandit.json || true

      - name: Convert Bandit JSON to SARIF
        run: |
          # Certifique-se de que o script 'scripts/bandit_to_sarif.py' existe
          # e converte 'bandit.json' para 'bandit-results.sarif'.
          # Um exemplo de script foi fornecido na resposta anterior.
          python scripts/bandit_to_sarif.py

      - name: Upload Bandit SARIF results to Code Scanning
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: bandit-results.sarif
          category: 'bandit-scan' # Categoria única para Bandit

      - name: Upload Bandit SARIF Artifact
        uses: actions/upload-artifact@v4 # Atualizado para v4
        with:
          name: bandit-sarif # Nome do artefato
          path: bandit-results.sarif # Caminho do arquivo a ser upado

  # Novo Job para comentar no Pull Request
  cve_comment:
    name: Comentar CVEs no PR
    runs-on: ubuntu-latest
    needs: security # Este job depende do job 'security' para garantir que os SARIFs sejam gerados
    if: github.event_name == 'pull_request' # Executar apenas em eventos de Pull Request

    permissions:
      pull-requests: write # Permissão necessária para o bot comentar em PRs

    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Download SARIF Artifacts
        uses: actions/download-artifact@v4 # Atualizado para v4
        with:
          # Com v4, os artefatos são baixados diretamente para o diretório especificado,
          # sem subdiretórios com o nome do artefato.
          path: sarif-artifacts

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: 3.9

      - name: Install Python dependencies
        run: |
          pip install --upgrade pip

      - name: Create scripts directory
        run: mkdir -p scripts # Garante que o diretório 'scripts' exista

      - name: Create SARIF to Markdown script
        run: |
          # Este comando cria o arquivo Python 'generate_cve_table.py'
          # no diretório 'scripts' com o conteúdo abaixo.
          # Este é o código Python aprimorado para gerar a tabela corretamente.
          cat << 'EOF' > scripts/generate_cve_table.py
          import json
          import os
          import sys

          def parse_sarif_file(file_path):
              vulnerabilities = []
              try:
                  with open(file_path, 'r', encoding='utf-8') as f:
                      sarif_data = json.load(f)

                  for run in sarif_data.get('runs', []):
                      tool_name = run.get('tool', {}).get('driver', {}).get('name', 'Ferramenta Desconhecida')
                      rules = {rule.get('id'): rule for rule in run.get('tool', {}).get('driver', {}).get('rules', [])}

                      for result in run.get('results', []):
                          cve_id = None
                          severity_level = result.get('level', 'note').upper()
                          severity = 'UNKNOWN'

                          description = result.get('message', {}).get('text', 'Sem descrição').strip()
                          location = 'N/A'
                          link = 'N/A'
                          package = 'N/A'
                          fixed_version = 'N/A'

                          rule_id = result.get('ruleId')
                          if rule_id and rule_id.startswith('CVE-'):
                              cve_id = rule_id
                          elif 'properties' in result and 'vulnerability-id' in result['properties']:
                              if result['properties']['vulnerability-id'].startswith('CVE-'):
                                  cve_id = result['properties']['vulnerability-id']

                          if 'properties' in result and 'security-severity' in result['properties']:
                              try:
                                  sec_severity = float(result['properties']['security-severity'])
                                  if sec_severity >= 9.0:
                                      severity = 'CRITICAL'
                                  elif sec_severity >= 7.0:
                                      severity = 'HIGH'
                                  elif sec_severity >= 4.0:
                                      severity = 'MEDIUM'
                                  else:
                                      severity = 'LOW'
                              except ValueError:
                                  pass

                          if severity == 'UNKNOWN':
                              if severity_level == 'ERROR':
                                  severity = 'HIGH'
                              elif severity_level == 'WARNING':
                                  severity = 'MEDIUM'
                              elif severity_level == 'NOTE':
                                  severity = 'LOW'

                          if 'locations' in result and result['locations']:
                              physical_location = result['locations'][0].get('physicalLocation', {})
                              artifact_location = physical_location.get('artifactLocation', {})
                              uri = artifact_location.get('uri')
                              if uri:
                                  location = os.path.basename(uri)

                          if rule_id and rule_id in rules and 'helpUri' in rules[rule_id]:
                              link = rules[rule_id]['helpUri']
                          if 'properties' in result and 'link' in result['properties']:
                              link = result['properties']['link']
                          if "Link: [" in description and "](https://" in description:
                              try:
                                  link_start = description.find("](https://") + 3
                                  link_end = description.find(")", link_start)
                                  extracted_link = description[link_start:link_end]
                                  if extracted_link.startswith("https://"):
                                      link = extracted_link
                              except Exception:
                                  pass

                          if 'properties' in result:
                              if 'PkgName' in result['properties']:
                                  package = result['properties']['PkgName']
                              if 'FixedVersion' in result['properties']:
                                  fixed_version = result['properties']['FixedVersion']
                          
                          original_description = description
                          if "Package:" in original_description and "Installed Version:" in original_description:
                              try:
                                  pkg_info_start = original_description.find("Package:")
                                  fixed_version_info_start = original_description.find("Fixed Version:")
                                  if fixed_version_info_start != -1:
                                      description = original_description[:fixed_version_info_start].strip()
                                  else:
                                      first_comma_after_pkg = original_description.find(",", pkg_info_start)
                                      if first_comma_after_pkg != -1:
                                          description = original_description[:first_comma_after_pkg].strip()
                                      else:
                                          description = original_description

                                  if package == 'N/A' and "Package:" in original_description:
                                      pkg_start = original_description.find("Package:") + len("Package:")
                                      pkg_end = original_description.find(" ", pkg_start)
                                      package = original_description[pkg_start:pkg_end].strip()

                                  if fixed_version == 'N/A' and "Fixed Version:" in original_description:
                                      fixed_start = original_description.find("Fixed Version:") + len("Fixed Version:")
                                      fixed_end = original_description.find(" ", fixed_start)
                                      fixed_version = original_description[fixed_start:fixed_end].strip()
                              except Exception as e:
                                  print(f"Erro ao analisar descrição para pacote/versão: {e}", file=sys.stderr)
                                  description = original_description


                          if cve_id:
                              vulnerabilities.append({
                                  'tool': tool_name,
                                  'cve_id': cve_id,
                                  'severity': severity,
                                  'description': description,
                                  'location': location,
                                  'package': package,
                                  'fixed_version': fixed_version,
                                  'link': link
                              })
              except json.JSONDecodeError as e:
                  print(f"Erro de decodificação JSON no arquivo SARIF {file_path}: {e}", file=sys.stderr)
              except Exception as e:
                  print(f"Erro ao analisar arquivo SARIF {file_path}: {e}", file=sys.stderr)
              return vulnerabilities

          def generate_markdown_table(vulnerabilities):
              if not vulnerabilities:
                  return "🎉 Parabéns! Nenhuma vulnerabilidade CVE crítica, alta ou média foi encontrada neste Pull Request. 🎉\n\nContinue com o bom trabalho!"

              severity_order = {'CRITICAL': 0, 'HIGH': 1, 'MEDIUM': 2, 'LOW': 3, 'NOTE': 4, 'UNKNOWN': 5}
              sorted_vulnerabilities = sorted(vulnerabilities, key=lambda x: severity_order.get(x['severity'], 99))

              markdown = "### 🚨 Resumo de Vulnerabilidades CVE Encontradas 🚨\n\n"
              markdown += "Esta tabela lista as vulnerabilidades CVE detectadas neste Pull Request com severidade Crítica, Alta ou Média.\n\n"
              # Linha de cabeçalho da tabela Markdown
              markdown += "| Ferramenta | CVE ID | Severidade | Pacote | Versão Corrigida | Descrição | Localização | Link |\n"
              # Linha de alinhamento da tabela Markdown (crucial para o GitHub renderizar a tabela)
              markdown += "|:---|:---|:---|:---|:---|:---|:---|:---|\n"

              for vul in sorted_vulnerabilities:
                  tool = vul['tool']
                  cve_id = vul['cve_id']
                  severity = vul['severity']
                  package = vul['package']
                  fixed_version = vul['fixed_version']
                  
                  # Escapa caracteres especiais para que não quebrem a tabela Markdown
                  description = vul['description'].replace('\n', ' ').replace('|', '\\|').replace('*', '\\*')

                  location = vul['location'].replace('|', '\\|')
                  link = vul['link']

                  # Trunca a descrição se for muito longa para manter a tabela compacta
                  if len(description) > 150:
                      description = description[:147] + "..."

                  # Formata o link para ser clicável no Markdown
                  formatted_link = f"[Link]({link})" if link and link != 'N/A' else 'N/A'

                  # Constrói a linha da tabela com separadores '|'
                  markdown += f"| {tool} | {cve_id} | **{severity}** | {package} | {fixed_version} | {description} | {location} | {formatted_link} |\n"

              markdown += "\n*Observação: A severidade é baseada na classificação da ferramenta de segurança.*"
              return markdown

          if __name__ == "__main__":
              sarif_files_to_process = []
              for root, _, files in os.walk('sarif-artifacts'):
                  for file in files:
                      if file.endswith('.sarif'):
                          sarif_files_to_process.append(os.path.join(root, file))

              all_vulnerabilities = []
              for sarif_file in sarif_files_to_process:
                  all_vulnerabilities.extend(parse_sarif_file(sarif_file))

              filtered_vulnerabilities = [
                  v for v in all_vulnerabilities
                  if v['severity'] in ['CRITICAL', 'HIGH', 'MEDIUM']
              ]

              markdown_output = generate_markdown_table(filtered_vulnerabilities)

              with open('cve_summary.md', 'w', encoding='utf-8') as f:
                  f.write(markdown_output)
          EOF

      - name: Generate CVE Table Markdown
        run: python scripts/generate_cve_table.py

      - name: Create or Update PR Comment
        uses: peter-evans/create-or-update-comment@v3
        with:
          issue-number: ${{ github.event.pull_request.number }}
          body-path: cve_summary.md
          comment-id: 'cve-summary-comment'
          update-mode: replace
